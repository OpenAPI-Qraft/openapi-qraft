import type { AsyncAPIDocumentInterface } from '@asyncapi/parser';
import type ts from 'typescript';
import type { AsyncAPIContext, AsyncAPITSOptions } from './types.js';
import { performance } from 'node:perf_hooks';
import { fromFile, fromURL, Parser } from '@asyncapi/parser';
import { debug } from 'openapi-typescript/dist/lib/utils.js';
import transformAsyncAPISchema from './transform/index.js';

export * from './types.js';
export { astToString } from 'openapi-typescript/dist/lib/ts.js';

export const COMMENT_HEADER = `/**
 * This file was auto-generated by openapi-typescript (asyncapi).
 * Do not make direct changes to the file.
 */

`;

function resolveRef<T>(
  schema: Record<string, unknown>,
  $ref: string
): T | undefined {
  if (!$ref || !$ref.startsWith('#/')) {
    return undefined;
  }

  const parts = $ref.slice(2).split('/');
  let current: unknown = schema;

  for (const part of parts) {
    if (current && typeof current === 'object' && part in current) {
      current = (current as Record<string, unknown>)[part];
    } else {
      return undefined;
    }
  }

  return current as T;
}

export default async function asyncapiTS(
  source: string | URL | Record<string, unknown>,
  options: AsyncAPITSOptions = {}
): Promise<ts.Node[]> {
  if (!source) {
    throw new Error(
      'Empty schema. Please specify a URL, file path, or AsyncAPI document object'
    );
  }

  const parser = new Parser();
  let parseResult: {
    document: AsyncAPIDocumentInterface | undefined;
    diagnostics: unknown[];
  };

  const parseStartT = performance.now();

  if (
    source instanceof URL ||
    (typeof source === 'string' &&
      (source.startsWith('http://') || source.startsWith('https://')))
  ) {
    const url = source instanceof URL ? source.toString() : source;
    parseResult = await fromURL(parser, url).parse();
  } else if (
    typeof source === 'string' &&
    !source.trim().startsWith('{') &&
    !source.includes('asyncapi:')
  ) {
    parseResult = await fromFile(parser, source).parse();
  } else {
    const sourceString =
      typeof source === 'string' ? source : JSON.stringify(source);
    parseResult = await parser.parse(sourceString);
  }

  debug(
    'Parsed AsyncAPI document',
    'asyncapi',
    performance.now() - parseStartT
  );

  const { document, diagnostics } = parseResult;

  if (!document) {
    const errors = (diagnostics as Array<{ message?: string }>)
      .filter((d) => d.message)
      .map((d) => d.message)
      .join('\n');
    throw new Error(
      `Failed to parse AsyncAPI document:\n${errors || 'Unknown error'}`
    );
  }

  const rawSchema =
    typeof source === 'string'
      ? source.trim().startsWith('{')
        ? JSON.parse(source)
        : document.json()
      : source;

  const ctx: AsyncAPIContext = {
    alphabetize: options.alphabetize ?? false,
    additionalProperties: options.additionalProperties ?? false,
    defaultNonNullable: options.defaultNonNullable ?? true,
    emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,
    enum: options.enum ?? false,
    enumValues: options.enumValues ?? false,
    dedupeEnums: options.dedupeEnums ?? false,
    excludeDeprecated: options.excludeDeprecated ?? false,
    exportType: options.exportType ?? false,
    immutable: options.immutable ?? false,
    propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,
    silent: options.silent ?? false,
    transform:
      typeof options.transform === 'function' ? options.transform : undefined,
    postTransform:
      typeof options.postTransform === 'function'
        ? options.postTransform
        : undefined,
    injectFooter: [],
    document,
    rawSchema: rawSchema as Record<string, unknown>,
    resolve<T>($ref: string): T | undefined {
      return resolveRef<T>(rawSchema as Record<string, unknown>, $ref);
    },
  };

  const transformT = performance.now();
  const result = transformAsyncAPISchema(ctx);
  debug(
    'Completed AST transformation for AsyncAPI document',
    'asyncapi',
    performance.now() - transformT
  );

  return result;
}
