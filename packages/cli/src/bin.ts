#!/usr/bin/env node
import c from 'ansi-colors';
import { program } from 'commander';
import fs from 'node:fs';
import { sep } from 'node:path';
import { pathToFileURL } from 'node:url';

import { fileHeader } from './lib/fileHeader.js';
import { writeOpenAPIServices } from './writeOpenAPIServices.js';

program
  .description(
    'Generate services declarations and Typed React Query Interfaces from OpenAPI Schema'
  )
  .argument('[input]', 'Input OpenAPI Schema file path, URL (json, yml)', null)
  .requiredOption(
    '-o, --output-dir <path>',
    'Output directory for generated services'
  )
  .requiredOption(
    '--openapi-types-import-path <path>', // todo::specify better param name to avoid confusion with real path
    'Path to schema types file (.d.ts), eg: "../openapi.d.ts"'
  )
  .option('-rm, --clean', 'Clean output directory before generating services')
  .option(
    '--filter-services <glob-pattern>',
    'Filter services to be generated by glob pattern. Eg: "/user/**,/post/**". See NPM `micromatch` package for more details.'
  )
  .option(
    '--operation-generics-import-path <path>',
    'Path to operation generics file',
    '@openapi-qraft/react'
  )
  .option(
    '--file-header <string>',
    'Header to be added to the generated file (eg: /* eslint-disable */)'
  )
  .option(
    '--postfix-services <string>',
    'Postfix to be added to the generated service name (eg: Service)'
  )
  .option(
    '--explicit-import-extensions',
    'All import statements will include explicit `.js` extensions. Ideal for projects using ECMAScript modules.'
  )
  .option(
    '--service-name-base <endpoint[<index>] | tags>',
    'Use OpenAPI Operation `endpoint[<index>]` path part (e.g.: "/0/1/2") or `tags` as the base name of the service.',
    'endpoint[0]'
  )
  .action(async (input, args) => {
    const { version: packageVersion, name: packageName } = JSON.parse(
      fs.readFileSync(new URL('../package.json', import.meta.url), 'utf8')
    );

    if (args.version) {
      console.info(`v${packageVersion}`);
      process.exit(0);
    }

    console.info(`âœ¨ ${c.bold(`${packageName} ${packageVersion}`)}`);

    const source = input
      ? new URL(input, pathToFileURL(`${process.cwd()}/`))
      : process.stdin;

    if (source === process.stdin && source.isTTY) {
      console.error(
        c.red(
          'Input file not found or stdin is empty. Please specify `--input` option or pipe OpenAPI Schema to stdin.'
        )
      );

      process.exit(1);
    }

    const servicesGlob = args.filterServices
      ? args.filterServices
          .split(',')
          .filter((item: unknown) => typeof item === 'string' && item.trim())
      : undefined;

    await writeOpenAPIServices({
      source,
      serviceImports: {
        operationGenericsImportPath: args.operationGenericsImportPath,
        openapiTypesImportPath: args.openapiTypesImportPath,
      },
      servicesGlob,
      output: {
        dir: pathToFileURL(
          args.outputDir.endsWith(sep)
            ? args.outputDir
            : `${args.outputDir}${sep}`
        ),
        clean: args.clean,
        fileHeader: args.fileHeader ?? fileHeader,
        postfixServices: args.postfixServices,
        explicitImportExtensions: args.explicitImportExtensions,
        servicesDirName: 'services',
        serviceNameBase: args.serviceNameBase,
      },
    }).catch((error) => {
      if (error instanceof Error)
        console.error(c.red(error.message), c.red(error.stack ?? ''));
      console.error(error);
      process.exit(1);
    });
  });

program.parse(process.argv);
