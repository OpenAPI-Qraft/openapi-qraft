/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../../openapi.d.ts";
import type { DeepReadonly, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, Updater } from "@tanstack/query-core";
import type { DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
export interface FilesService {
    /** @summary Get a files by ID */
    getFiles: {
        /** @summary Get a files by ID */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: CancelOptions): Promise<void>;
        /** @summary Get a files by ID */
        getQueryKey(parameters: DeepReadonly<GetFilesParameters>): ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFiles.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options?: Omit<UndefinedInitialDataOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): UseQueryResult<TData, GetFilesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFiles.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<DefinedInitialDataOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetFilesError | Error>;
        /** @summary Get a files by ID */
        fetchInfiniteQuery<TPageParam extends GetFilesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, DeepReadonly<TPageParam>, GetFilesError>): Promise<OperationInfiniteData<GetFilesData, GetFilesParameters>>;
        /** @summary Get a files by ID */
        prefetchInfiniteQuery<TPageParam extends GetFilesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, DeepReadonly<TPageParam>, GetFilesError>): Promise<void>;
        /** @summary Get a files by ID */
        ensureInfiniteQueryData<TPageParam extends GetFilesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetFilesSchema, GetFilesData, GetFilesParameters, DeepReadonly<TPageParam>, GetFilesError>): Promise<OperationInfiniteData<GetFilesData, GetFilesParameters>>;
        /** @summary Get a files by ID */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, GetFilesError>): Promise<GetFilesData>;
        /** @summary Get a files by ID */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, GetFilesError>): Promise<void>;
        /** @summary Get a files by ID */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetFilesSchema, GetFilesData, GetFilesParameters, GetFilesError>): Promise<GetFilesData>;
        /** @summary Get a files by ID */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>)): OperationInfiniteData<GetFilesData, GetFilesParameters> | undefined;
        /** @summary Get a files by ID */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>,
            data: NoInfer<OperationInfiniteData<GetFilesData, GetFilesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>,
            data: GetFilesData | undefined
        ]>;
        /** @summary Get a files by ID */
        getQueryData(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>)): GetFilesData | undefined;
        /** @summary Get a files by ID */
        getQueryState(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>)): QueryState<GetFilesData, GetFilesError> | undefined;
        /** @summary Get a files by ID */
        getInfiniteQueryState(parameters: DeepReadonly<GetFilesParameters> | ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>): QueryState<OperationInfiniteData<GetFilesData, GetFilesParameters>, GetFilesError> | undefined;
        /** @summary Get a files by ID */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Get a files by ID */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): number;
        /** @summary Get a files by ID */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: RefetchOptions): Promise<void>;
        /** @summary Get a files by ID */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): void;
        /** @summary Get a files by ID */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: ResetOptions): Promise<void>;
        /** @summary Get a files by ID */
        setInfiniteQueryData(parameters: (DeepReadonly<GetFilesParameters>) | ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetFilesData, GetFilesParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetFilesData, GetFilesParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetFilesData, GetFilesParameters> | undefined;
        /** @summary Get a files by ID */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, updater: Updater<NoInfer<GetFilesData> | undefined, NoInfer<GetFilesData> | undefined>, options?: SetDataOptions): Array<GetFilesData | undefined>;
        /** @summary Get a files by ID */
        setQueryData(parameters: (DeepReadonly<GetFilesParameters>) | ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>, updater: Updater<NoInfer<GetFilesData> | undefined, NoInfer<DeepReadonly<GetFilesData>> | undefined>, options?: SetDataOptions): GetFilesData | undefined;
        /** @summary Get a files by ID */
        getInfiniteQueryKey(parameters: DeepReadonly<GetFilesParameters>): ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.getFiles.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFilesParameters, TQueryFnData = GetFilesData, TData = OperationInfiniteData<TQueryFnData, GetFilesParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetFilesError, TData, ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, GetFilesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.getFiles.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFilesParameters, TQueryFnData = GetFilesData, TData = OperationInfiniteData<TQueryFnData, GetFilesParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetFilesError, TData, ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetFilesData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, GetFilesError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getFilesTotal = qraft.filesService.getFiles.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getFilesByParametersTotal = qraft.filesService.getFiles.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         header: {
         *             "x-monite-version": "2023-06-04"
         *         },
         *         query: {
         *             id__in: idIn
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getFilesResults = qraft.filesService.getFiles.useQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getFilesCombinedResults = qraft.filesService.getFiles.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetFilesSchema, GetFilesParameters, GetFilesData, GetFilesError>>, TCombinedResult = Array<UseQueryResult<GetFilesData, GetFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetFilesData, GetFilesError>>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get a files by ID */
        getQueryKey(parameters: DeepReadonly<GetFilesParameters>): ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFiles.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options?: Omit<UndefinedInitialDataOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): UseQueryResult<TData, GetFilesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFiles.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<DefinedInitialDataOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetFilesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.getFiles.useSuspenseInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetFilesParameters, TData = GetFilesData>(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<GetFilesData, GetFilesError, OperationInfiniteData<TData, GetFilesParameters>, GetFilesData, ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetFilesData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetFilesParameters>, GetFilesError | Error>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getFilesData = qraft.filesService.getFiles.useSuspenseQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getFilesCombinedData = qraft.filesService.getFiles.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetFilesSchema, GetFilesParameters, GetFilesData, GetFilesError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetFilesData, GetFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetFilesData, GetFilesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.filesService.getFiles.useSuspenseQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options?: Omit<UseSuspenseQueryOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetFilesError | Error>;
        schema: GetFilesSchema;
        types: {
            parameters: GetFilesParameters;
            data: GetFilesData;
            error: GetFilesError;
        };
    };
    /** @summary Upload a files by ID */
    postFiles: {
        /** @summary Upload a files by ID */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>, options?: CancelOptions): Promise<void>;
        /** @summary Upload a files by ID */
        getQueryKey(parameters: DeepReadonly<PostFilesQueryParameters> | void): ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery({
         *     body: queryBody
         * })
         * ```
         */
        useQuery<TData = PostFilesData>(parameters: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options?: Omit<UndefinedInitialDataOptions<PostFilesData, PostFilesError, TData, ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>>, "queryKey">): UseQueryResult<TData, PostFilesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery({
         *     body: queryBody
         * })
         * ```
         */
        useQuery<TData = PostFilesData>(parameters: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options: Omit<DefinedInitialDataOptions<PostFilesData, PostFilesError, TData, ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>>, "queryKey">): DefinedUseQueryResult<TData, PostFilesError | Error>;
        /** @summary Upload a files by ID */
        fetchInfiniteQuery<TPageParam extends PostFilesQueryParameters>(options: ServiceOperationFetchInfiniteQueryOptions<PostFilesSchema, PostFilesData, PostFilesQueryParameters, DeepReadonly<TPageParam>, PostFilesError> | void): Promise<OperationInfiniteData<PostFilesData, PostFilesQueryParameters>>;
        /** @summary Upload a files by ID */
        prefetchInfiniteQuery<TPageParam extends PostFilesQueryParameters>(options: ServiceOperationFetchInfiniteQueryOptions<PostFilesSchema, PostFilesData, PostFilesQueryParameters, DeepReadonly<TPageParam>, PostFilesError> | void): Promise<void>;
        /** @summary Upload a files by ID */
        ensureInfiniteQueryData<TPageParam extends PostFilesQueryParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<PostFilesSchema, PostFilesData, PostFilesQueryParameters, DeepReadonly<TPageParam>, PostFilesError> | void): Promise<OperationInfiniteData<PostFilesData, PostFilesQueryParameters>>;
        /** @summary Upload a files by ID */
        fetchQuery(options: ServiceOperationFetchQueryOptions<PostFilesSchema, PostFilesData, PostFilesQueryParameters, PostFilesError> | void): Promise<PostFilesData>;
        /** @summary Upload a files by ID */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<PostFilesSchema, PostFilesData, PostFilesQueryParameters, PostFilesError> | void): Promise<void>;
        /** @summary Upload a files by ID */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<PostFilesSchema, PostFilesData, PostFilesQueryParameters, PostFilesError> | void): Promise<PostFilesData>;
        /** @summary Upload a files by ID */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void)): OperationInfiniteData<PostFilesData, PostFilesQueryParameters> | undefined;
        /** @summary Upload a files by ID */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters>,
            data: NoInfer<OperationInfiniteData<PostFilesData, PostFilesQueryParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>,
            data: PostFilesData | undefined
        ]>;
        /** @summary Upload a files by ID */
        getQueryData(parameters: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void)): PostFilesData | undefined;
        /** @summary Upload a files by ID */
        getQueryState(parameters: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void)): QueryState<PostFilesData, PostFilesError> | undefined;
        /** @summary Upload a files by ID */
        getInfiniteQueryState(parameters: DeepReadonly<PostFilesQueryParameters> | ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters> | void): QueryState<OperationInfiniteData<PostFilesData, PostFilesQueryParameters>, PostFilesError> | undefined;
        /** @summary Upload a files by ID */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Upload a files by ID */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>): number;
        /** @summary Upload a files by ID */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>, options?: RefetchOptions): Promise<void>;
        /** @summary Upload a files by ID */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>): void;
        /** @summary Upload a files by ID */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>, options?: ResetOptions): Promise<void>;
        /** @summary Upload a files by ID */
        setInfiniteQueryData(parameters: (DeepReadonly<PostFilesQueryParameters> | undefined) | ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters>, updater: Updater<NoInfer<OperationInfiniteData<PostFilesData, PostFilesQueryParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<PostFilesData, PostFilesQueryParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<PostFilesData, PostFilesQueryParameters> | undefined;
        /** @summary Upload a files by ID */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>, updater: Updater<NoInfer<PostFilesData> | undefined, NoInfer<PostFilesData> | undefined>, options?: SetDataOptions): Array<PostFilesData | undefined>;
        /** @summary Upload a files by ID */
        setQueryData(parameters: (DeepReadonly<PostFilesQueryParameters> | undefined) | ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>, updater: Updater<NoInfer<PostFilesData> | undefined, NoInfer<DeepReadonly<PostFilesData>> | undefined>, options?: SetDataOptions): PostFilesData | undefined;
        /** @summary Upload a files by ID */
        getInfiniteQueryKey(parameters: DeepReadonly<PostFilesQueryParameters> | void): ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.postFiles.useInfiniteQuery({
         *     body: queryBody
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends PostFilesQueryParameters, TQueryFnData = PostFilesData, TData = OperationInfiniteData<TQueryFnData, PostFilesQueryParameters>>(parameters: ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, PostFilesError, TData, ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, PostFilesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.postFiles.useInfiniteQuery({
         *     body: queryBody
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends PostFilesQueryParameters, TQueryFnData = PostFilesData, TData = OperationInfiniteData<TQueryFnData, PostFilesQueryParameters>>(parameters: ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, PostFilesError, TData, ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<PostFilesData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, PostFilesError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const postFilesTotal = qraft.filesService.postFiles.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const postFilesByParametersTotal = qraft.filesService.postFiles.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         body: queryBody
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError> | QueryFiltersByQueryKey<PostFilesSchema, PostFilesData, TInfinite, PostFilesQueryParameters, PostFilesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const postFilesResults = qraft.filesService.postFiles.useQueries({
         *     queries: [
         *         {
         *             body: queryBody1
         *         },
         *         {
         *             body: queryBody2
         *         }
         *     ]
         * });
         * postFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const postFilesCombinedResults = qraft.filesService.postFiles.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             body: queryBody1
         *         },
         *         {
         *             body: queryBody2
         *         }
         *     ]
         * });
         * postFilesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<PostFilesSchema, PostFilesQueryParameters, PostFilesData, PostFilesError>>, TCombinedResult = Array<UseQueryResult<PostFilesData, PostFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<PostFilesData, PostFilesError>>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Upload a files by ID */
        getQueryKey(parameters: DeepReadonly<PostFilesQueryParameters> | void): ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery({
         *     body: queryBody
         * })
         * ```
         */
        useQuery<TData = PostFilesData>(parameters: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options?: Omit<UndefinedInitialDataOptions<PostFilesData, PostFilesError, TData, ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>>, "queryKey">): UseQueryResult<TData, PostFilesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.postFiles.useQuery({
         *     body: queryBody
         * })
         * ```
         */
        useQuery<TData = PostFilesData>(parameters: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options: Omit<DefinedInitialDataOptions<PostFilesData, PostFilesError, TData, ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>>, "queryKey">): DefinedUseQueryResult<TData, PostFilesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.postFiles.useSuspenseInfiniteQuery({
         *     body: queryBody
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends PostFilesQueryParameters, TData = PostFilesData>(parameters: ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<PostFilesData, PostFilesError, OperationInfiniteData<TData, PostFilesQueryParameters>, PostFilesData, ServiceOperationInfiniteQueryKey<PostFilesSchema, PostFilesQueryParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<PostFilesData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, PostFilesQueryParameters>, PostFilesError | Error>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const postFilesData = qraft.filesService.postFiles.useSuspenseQueries({
         *     queries: [
         *         {
         *             body: queryBody1
         *         },
         *         {
         *             body: queryBody2
         *         }
         *     ]
         * });
         * postFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const postFilesCombinedData = qraft.filesService.postFiles.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             body: queryBody1
         *         },
         *         {
         *             body: queryBody2
         *         }
         *     ]
         * });
         * postFilesCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<PostFilesSchema, PostFilesQueryParameters, PostFilesData, PostFilesError>>, TCombinedResult = Array<UseSuspenseQueryResult<PostFilesData, PostFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<PostFilesData, PostFilesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.filesService.postFiles.useSuspenseQuery()
         * ```
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.filesService.postFiles.useSuspenseQuery({
         *     body: queryBody
         * })
         * ```
         */
        useSuspenseQuery<TData = PostFilesData>(parameters: ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters> | (DeepReadonly<PostFilesQueryParameters> | void), options?: Omit<UseSuspenseQueryOptions<PostFilesData, PostFilesError, TData, ServiceOperationQueryKey<PostFilesSchema, PostFilesQueryParameters>>, "queryKey">): UseSuspenseQueryResult<TData, PostFilesError | Error>;
        /** @summary Upload a files by ID */
        getMutationKey(parameters: DeepReadonly<PostFilesMutationParameters> | void): ServiceOperationMutationKey<PostFilesSchema, PostFilesMutationParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.postFiles.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.postFiles.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostFilesBody, TContext = unknown>(parameters: DeepReadonly<PostFilesMutationParameters>, options?: ServiceOperationUseMutationOptions<PostFilesSchema, PostFilesData, PostFilesMutationParameters, TVariables, PostFilesError | Error, TContext>): UseMutationResult<PostFilesData, PostFilesError | Error, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.postFiles.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.postFiles.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostFilesBody, PostFilesMutationParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostFilesSchema, PostFilesData, PostFilesMutationParameters, TVariables, PostFilesError | Error, TContext>): UseMutationResult<PostFilesData, PostFilesError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postFilesTotal = qraft.filesService.postFiles.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postFilesTotal = qraft.filesService.postFiles.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesMutationParameters, PostFilesError | Error, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesMutationParameters, PostFilesError | Error, TContext>): number;
        /** @summary Upload a files by ID */
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesMutationParameters, PostFilesError | Error, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesMutationParameters, PostFilesError | Error, TContext>): number;
        /** @summary Upload a files by ID */
        (options: ServiceOperationMutationFnOptions<PostFilesBody, PostFilesMutationParameters>, client?: (schema: PostFilesSchema, options: ServiceOperationMutationFnOptions<PostFilesBody, PostFilesMutationParameters>) => Promise<RequestFnResponse<PostFilesData, PostFilesError>>): Promise<RequestFnResponse<PostFilesData, PostFilesError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postFilesPendingMutationVariables = qraft.filesService.postFiles.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postFilesMutationData = qraft.filesService.postFiles.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostFilesData, PostFilesError | Error, MutationVariables<PostFilesBody, PostFilesMutationParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesMutationParameters, PostFilesError | Error, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesMutationParameters, PostFilesError | Error, TContext>;
            select?: (mutation: Mutation<PostFilesData, PostFilesError | Error, MutationVariables<PostFilesBody, PostFilesMutationParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostFilesSchema;
        types: {
            parameters: PostFilesMutationParameters;
            data: PostFilesData;
            error: PostFilesError;
            body: PostFilesBody;
        };
    };
    /** @summary Delete all files */
    deleteFiles: {
        /** @summary Delete all files */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>, options?: CancelOptions): Promise<void>;
        /** @summary Delete all files */
        getQueryKey(parameters: DeepReadonly<DeleteFilesParameters> | void): ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery({
         *     query: {
         *         all: all
         *     }
         * })
         * ```
         */
        useQuery<TData = DeleteFilesData>(parameters: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options?: Omit<UndefinedInitialDataOptions<DeleteFilesData, DeleteFilesError, TData, ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>>, "queryKey">): UseQueryResult<TData, DeleteFilesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery({
         *     query: {
         *         all: all
         *     }
         * })
         * ```
         */
        useQuery<TData = DeleteFilesData>(parameters: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options: Omit<DefinedInitialDataOptions<DeleteFilesData, DeleteFilesError, TData, ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>>, "queryKey">): DefinedUseQueryResult<TData, DeleteFilesError | Error>;
        /** @summary Delete all files */
        fetchInfiniteQuery<TPageParam extends DeleteFilesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, DeepReadonly<TPageParam>, DeleteFilesError> | void): Promise<OperationInfiniteData<DeleteFilesData, DeleteFilesParameters>>;
        /** @summary Delete all files */
        prefetchInfiniteQuery<TPageParam extends DeleteFilesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, DeepReadonly<TPageParam>, DeleteFilesError> | void): Promise<void>;
        /** @summary Delete all files */
        ensureInfiniteQueryData<TPageParam extends DeleteFilesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, DeepReadonly<TPageParam>, DeleteFilesError> | void): Promise<OperationInfiniteData<DeleteFilesData, DeleteFilesParameters>>;
        /** @summary Delete all files */
        fetchQuery(options: ServiceOperationFetchQueryOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, DeleteFilesError> | void): Promise<DeleteFilesData>;
        /** @summary Delete all files */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, DeleteFilesError> | void): Promise<void>;
        /** @summary Delete all files */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, DeleteFilesError> | void): Promise<DeleteFilesData>;
        /** @summary Delete all files */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void)): OperationInfiniteData<DeleteFilesData, DeleteFilesParameters> | undefined;
        /** @summary Delete all files */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters>,
            data: NoInfer<OperationInfiniteData<DeleteFilesData, DeleteFilesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>,
            data: DeleteFilesData | undefined
        ]>;
        /** @summary Delete all files */
        getQueryData(parameters: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void)): DeleteFilesData | undefined;
        /** @summary Delete all files */
        getQueryState(parameters: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void)): QueryState<DeleteFilesData, DeleteFilesError> | undefined;
        /** @summary Delete all files */
        getInfiniteQueryState(parameters: DeepReadonly<DeleteFilesParameters> | ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters> | void): QueryState<OperationInfiniteData<DeleteFilesData, DeleteFilesParameters>, DeleteFilesError> | undefined;
        /** @summary Delete all files */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Delete all files */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>): number;
        /** @summary Delete all files */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>, options?: RefetchOptions): Promise<void>;
        /** @summary Delete all files */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>): void;
        /** @summary Delete all files */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>, options?: ResetOptions): Promise<void>;
        /** @summary Delete all files */
        setInfiniteQueryData(parameters: (DeepReadonly<DeleteFilesParameters> | undefined) | ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters>, updater: Updater<NoInfer<OperationInfiniteData<DeleteFilesData, DeleteFilesParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<DeleteFilesData, DeleteFilesParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<DeleteFilesData, DeleteFilesParameters> | undefined;
        /** @summary Delete all files */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>, updater: Updater<NoInfer<DeleteFilesData> | undefined, NoInfer<DeleteFilesData> | undefined>, options?: SetDataOptions): Array<DeleteFilesData | undefined>;
        /** @summary Delete all files */
        setQueryData(parameters: (DeepReadonly<DeleteFilesParameters> | undefined) | ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>, updater: Updater<NoInfer<DeleteFilesData> | undefined, NoInfer<DeepReadonly<DeleteFilesData>> | undefined>, options?: SetDataOptions): DeleteFilesData | undefined;
        /** @summary Delete all files */
        getInfiniteQueryKey(parameters: DeepReadonly<DeleteFilesParameters> | void): ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.deleteFiles.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             all: initialAll
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DeleteFilesParameters, TQueryFnData = DeleteFilesData, TData = OperationInfiniteData<TQueryFnData, DeleteFilesParameters>>(parameters: ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, DeleteFilesError, TData, ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, DeleteFilesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.deleteFiles.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             all: initialAll
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DeleteFilesParameters, TQueryFnData = DeleteFilesData, TData = OperationInfiniteData<TQueryFnData, DeleteFilesParameters>>(parameters: ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, DeleteFilesError, TData, ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DeleteFilesData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, DeleteFilesError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const deleteFilesTotal = qraft.filesService.deleteFiles.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const deleteFilesByParametersTotal = qraft.filesService.deleteFiles.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             all: all
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError> | QueryFiltersByQueryKey<DeleteFilesSchema, DeleteFilesData, TInfinite, DeleteFilesParameters, DeleteFilesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const deleteFilesResults = qraft.filesService.deleteFiles.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 all: all1
         *             }
         *         },
         *         {
         *             query: {
         *                 all: all2
         *             }
         *         }
         *     ]
         * });
         * deleteFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const deleteFilesCombinedResults = qraft.filesService.deleteFiles.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 all: all1
         *             }
         *         },
         *         {
         *             query: {
         *                 all: all2
         *             }
         *         }
         *     ]
         * });
         * deleteFilesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<DeleteFilesSchema, DeleteFilesParameters, DeleteFilesData, DeleteFilesError>>, TCombinedResult = Array<UseQueryResult<DeleteFilesData, DeleteFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<DeleteFilesData, DeleteFilesError>>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Delete all files */
        getQueryKey(parameters: DeepReadonly<DeleteFilesParameters> | void): ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery({
         *     query: {
         *         all: all
         *     }
         * })
         * ```
         */
        useQuery<TData = DeleteFilesData>(parameters: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options?: Omit<UndefinedInitialDataOptions<DeleteFilesData, DeleteFilesError, TData, ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>>, "queryKey">): UseQueryResult<TData, DeleteFilesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.deleteFiles.useQuery({
         *     query: {
         *         all: all
         *     }
         * })
         * ```
         */
        useQuery<TData = DeleteFilesData>(parameters: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options: Omit<DefinedInitialDataOptions<DeleteFilesData, DeleteFilesError, TData, ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>>, "queryKey">): DefinedUseQueryResult<TData, DeleteFilesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.deleteFiles.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             all: initialAll
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends DeleteFilesParameters, TData = DeleteFilesData>(parameters: ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<DeleteFilesData, DeleteFilesError, OperationInfiniteData<TData, DeleteFilesParameters>, DeleteFilesData, ServiceOperationInfiniteQueryKey<DeleteFilesSchema, DeleteFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DeleteFilesData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, DeleteFilesParameters>, DeleteFilesError | Error>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const deleteFilesData = qraft.filesService.deleteFiles.useSuspenseQueries({
         *     queries: [
         *         {
         *             query: {
         *                 all: all1
         *             }
         *         },
         *         {
         *             query: {
         *                 all: all2
         *             }
         *         }
         *     ]
         * });
         * deleteFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const deleteFilesCombinedData = qraft.filesService.deleteFiles.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 all: all1
         *             }
         *         },
         *         {
         *             query: {
         *                 all: all2
         *             }
         *         }
         *     ]
         * });
         * deleteFilesCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<DeleteFilesSchema, DeleteFilesParameters, DeleteFilesData, DeleteFilesError>>, TCombinedResult = Array<UseSuspenseQueryResult<DeleteFilesData, DeleteFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<DeleteFilesData, DeleteFilesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.filesService.deleteFiles.useSuspenseQuery()
         * ```
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.filesService.deleteFiles.useSuspenseQuery({
         *     query: {
         *         all: all
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = DeleteFilesData>(parameters: ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters> | (DeepReadonly<DeleteFilesParameters> | void), options?: Omit<UseSuspenseQueryOptions<DeleteFilesData, DeleteFilesError, TData, ServiceOperationQueryKey<DeleteFilesSchema, DeleteFilesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, DeleteFilesError | Error>;
        /** @summary Delete all files */
        getMutationKey(parameters: DeepReadonly<DeleteFilesParameters> | void): ServiceOperationMutationKey<DeleteFilesSchema, DeleteFilesParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.deleteFiles.useMutation({
         *     query: {
         *         all: all
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.deleteFiles.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         all: all
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteFilesBody, TContext = unknown>(parameters: DeepReadonly<DeleteFilesParameters>, options?: ServiceOperationUseMutationOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, TVariables, DeleteFilesError | Error, TContext>): UseMutationResult<DeleteFilesData, DeleteFilesError | Error, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.deleteFiles.useMutation({
         *     query: {
         *         all: all
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.filesService.deleteFiles.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         all: all
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, TVariables, DeleteFilesError | Error, TContext>): UseMutationResult<DeleteFilesData, DeleteFilesError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteFilesTotal = qraft.filesService.deleteFiles.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteFilesTotal = qraft.filesService.deleteFiles.useIsMutating({
         *     parameters: {
         *         query: {
         *             all: all
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, DeleteFilesError | Error, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, DeleteFilesError | Error, TContext>): number;
        /** @summary Delete all files */
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, DeleteFilesError | Error, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, DeleteFilesError | Error, TContext>): number;
        /** @summary Delete all files */
        (options: ServiceOperationMutationFnOptions<DeleteFilesBody, DeleteFilesParameters>, client?: (schema: DeleteFilesSchema, options: ServiceOperationMutationFnOptions<DeleteFilesBody, DeleteFilesParameters>) => Promise<RequestFnResponse<DeleteFilesData, DeleteFilesError>>): Promise<RequestFnResponse<DeleteFilesData, DeleteFilesError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteFilesPendingMutationVariables = qraft.filesService.deleteFiles.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteFilesMutationData = qraft.filesService.deleteFiles.useMutationState({
         *     filters: {
         *         parameters: {
         *             query: {
         *                 all: all
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteFilesData, DeleteFilesError | Error, MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, DeleteFilesError | Error, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, DeleteFilesError | Error, TContext>;
            select?: (mutation: Mutation<DeleteFilesData, DeleteFilesError | Error, MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: DeleteFilesSchema;
        types: {
            parameters: DeleteFilesParameters;
            data: DeleteFilesData;
            error: DeleteFilesError;
            body: DeleteFilesBody;
        };
    };
    /**
     * @deprecated
     * @summary Get a file list
     */
    getFileList: {
        /**
         * @deprecated
         * @summary Get a file list
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: CancelOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueryKey(parameters: DeepReadonly<GetFileListParameters> | void): ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options?: Omit<UndefinedInitialDataOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): UseQueryResult<TData, GetFileListError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<DefinedInitialDataOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetFileListError | Error>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        fetchInfiniteQuery<TPageParam extends GetFileListParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, DeepReadonly<TPageParam>, GetFileListError> | void): Promise<OperationInfiniteData<GetFileListData, GetFileListParameters>>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        prefetchInfiniteQuery<TPageParam extends GetFileListParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, DeepReadonly<TPageParam>, GetFileListError> | void): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        ensureInfiniteQueryData<TPageParam extends GetFileListParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetFileListSchema, GetFileListData, GetFileListParameters, DeepReadonly<TPageParam>, GetFileListError> | void): Promise<OperationInfiniteData<GetFileListData, GetFileListParameters>>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, GetFileListError> | void): Promise<GetFileListData>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, GetFileListError> | void): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetFileListSchema, GetFileListData, GetFileListParameters, GetFileListError> | void): Promise<GetFileListData>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void)): OperationInfiniteData<GetFileListData, GetFileListParameters> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>,
            data: NoInfer<OperationInfiniteData<GetFileListData, GetFileListParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>,
            data: GetFileListData | undefined
        ]>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void)): GetFileListData | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void)): QueryState<GetFileListData, GetFileListError> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetFileListParameters> | ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | void): QueryState<OperationInfiniteData<GetFileListData, GetFileListParameters>, GetFileListError> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): number;
        /**
         * @deprecated
         * @summary Get a file list
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: RefetchOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): void;
        /**
         * @deprecated
         * @summary Get a file list
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: ResetOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetFileListParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetFileListData, GetFileListParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetFileListData, GetFileListParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetFileListData, GetFileListParameters> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, updater: Updater<NoInfer<GetFileListData> | undefined, NoInfer<GetFileListData> | undefined>, options?: SetDataOptions): Array<GetFileListData | undefined>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        setQueryData(parameters: (DeepReadonly<GetFileListParameters> | undefined) | ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>, updater: Updater<NoInfer<GetFileListData> | undefined, NoInfer<DeepReadonly<GetFileListData>> | undefined>, options?: SetDataOptions): GetFileListData | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetFileListParameters> | void): ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.getFileList.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFileListParameters, TQueryFnData = GetFileListData, TData = OperationInfiniteData<TQueryFnData, GetFileListParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetFileListError, TData, ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, GetFileListError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.getFileList.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFileListParameters, TQueryFnData = GetFileListData, TData = OperationInfiniteData<TQueryFnData, GetFileListParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetFileListError, TData, ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetFileListData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, GetFileListError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getFileListTotal = qraft.filesService.getFileList.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getFileListByParametersTotal = qraft.filesService.getFileList.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         header: {
         *             "x-monite-version": "2023-06-04"
         *         },
         *         query: {
         *             id__in: idIn
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getFileListResults = qraft.filesService.getFileList.useQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getFileListCombinedResults = qraft.filesService.getFileList.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetFileListSchema, GetFileListParameters, GetFileListData, GetFileListError>>, TCombinedResult = Array<UseQueryResult<GetFileListData, GetFileListError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetFileListData, GetFileListError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueryKey(parameters: DeepReadonly<GetFileListParameters> | void): ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options?: Omit<UndefinedInitialDataOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): UseQueryResult<TData, GetFileListError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.filesService.getFileList.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<DefinedInitialDataOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetFileListError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.filesService.getFileList.useSuspenseInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetFileListParameters, TData = GetFileListData>(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetFileListData, GetFileListError, OperationInfiniteData<TData, GetFileListParameters>, GetFileListData, ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetFileListData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetFileListParameters>, GetFileListError | Error>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getFileListData = qraft.filesService.getFileList.useSuspenseQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getFileListCombinedData = qraft.filesService.getFileList.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetFileListSchema, GetFileListParameters, GetFileListData, GetFileListError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetFileListData, GetFileListError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetFileListData, GetFileListError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.filesService.getFileList.useSuspenseQuery()
         * ```
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.filesService.getFileList.useSuspenseQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options?: Omit<UseSuspenseQueryOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetFileListError | Error>;
        schema: GetFileListSchema;
        types: {
            parameters: GetFileListParameters;
            data: GetFileListData;
            error: GetFileListError;
        };
    };
}
export const filesService: {
    /** @summary Get a files by ID */
    getFiles: {
        schema: GetFilesSchema;
    };
    /** @summary Upload a files by ID */
    postFiles: {
        schema: PostFilesSchema;
    };
    /** @summary Delete all files */
    deleteFiles: {
        schema: DeleteFilesSchema;
    };
    /**
     * @deprecated
     * @summary Get a file list
     */
    getFileList: {
        schema: GetFileListSchema;
    };
} = {
    getFiles: {
        schema: {
            method: "get",
            url: "/files",
            security: ["HTTPBearer"]
        }
    },
    postFiles: {
        schema: {
            method: "post",
            url: "/files",
            mediaType: ["multipart/form-data"]
        }
    },
    deleteFiles: {
        schema: {
            method: "delete",
            url: "/files"
        }
    },
    getFileList: {
        schema: {
            method: "get",
            url: "/files/list",
            security: ["HTTPBearer"]
        }
    }
};
type GetFilesSchema = {
    method: "get";
    url: "/files";
    security: [
        "HTTPBearer"
    ];
};
type GetFilesParameters = paths["/files"]["get"]["parameters"];
type GetFilesData = paths["/files"]["get"]["responses"]["200"]["content"]["application/json"];
type GetFilesError = paths["/files"]["get"]["responses"]["405"]["content"]["application/json"] | paths["/files"]["get"]["responses"]["422"]["content"]["application/json"] | paths["/files"]["get"]["responses"]["default"]["content"]["application/json"];
type PostFilesSchema = {
    method: "post";
    url: "/files";
    mediaType: [
        "multipart/form-data"
    ];
};
type PostFilesQueryParameters = {
    query?: never;
    header?: never;
    path?: never;
} & {
    body?: PostFilesBody;
};
type PostFilesMutationParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type PostFilesData = paths["/files"]["post"]["responses"]["200"]["content"]["application/json"];
type PostFilesError = paths["/files"]["post"]["responses"]["default"]["content"]["application/json"];
type PostFilesBody = NonNullable<paths["/files"]["post"]["requestBody"]>["content"]["multipart/form-data"] | FormData;
type DeleteFilesSchema = {
    method: "delete";
    url: "/files";
};
type DeleteFilesParameters = paths["/files"]["delete"]["parameters"];
type DeleteFilesData = paths["/files"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteFilesError = paths["/files"]["delete"]["responses"]["default"]["content"]["application/json"];
type DeleteFilesBody = undefined;
type GetFileListSchema = {
    method: "get";
    url: "/files/list";
    security: [
        "HTTPBearer"
    ];
};
type GetFileListParameters = paths["/files/list"]["get"]["parameters"];
type GetFileListData = paths["/files/list"]["get"]["responses"]["200"]["content"]["application/json"];
type GetFileListError = paths["/files/list"]["get"]["responses"]["default"]["content"]["application/json"];
