/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../../openapi.d.ts";
import type { DeepReadonly, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationError, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional, QraftServiceOperationsToken } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationCache, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, Updater, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
import type { ParametersWrapper } from "../../type-overrides/parameters-wrapper.js";
export interface FilesService {
    /** @summary Get a files by ID */
    getFiles: {
        /** @summary Get a files by ID */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetFilesSchema, GetFilesParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetFilesParameters, TMeta, TSignal>), client?: (schema: GetFilesSchema, options: {
            parameters: GetFilesParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetFilesData, GetFilesError>>): Promise<RequestFnResponse<GetFilesData, GetFilesError>>;
        /** @summary Get a files by ID */
        getQueryKey(parameters: DeepReadonly<GetFilesParameters>): ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.files.getFiles.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<DefinedInitialDataOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetFilesError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.files.getFiles.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options?: Omit<UndefinedInitialDataOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetFilesError>>;
        /** @summary Get a files by ID */
        getInfiniteQueryKey(parameters: DeepReadonly<GetFilesParameters>): ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.files.getFiles.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFilesParameters, TQueryFnData = GetFilesData, TData = OperationInfiniteData<TQueryFnData, GetFilesParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetFilesError, TData, ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetFilesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.files.getFiles.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFilesParameters, TQueryFnData = GetFilesData, TData = OperationInfiniteData<TQueryFnData, GetFilesParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetFilesError, TData, ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetFilesError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getFilesTotal = qraft.files.getFiles.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getFilesByParametersTotal = qraft.files.getFiles.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         header: {
         *             "x-monite-version": "2023-06-04"
         *         },
         *         query: {
         *             id__in: idIn
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getFilesResults = qraft.files.getFiles.useQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getFilesCombinedResults = qraft.files.getFiles.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetFilesSchema, GetFilesParameters, GetFilesData, GetFilesError>>, TCombinedResult = Array<UseQueryResult<GetFilesData, GetFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetFilesData, GetFilesError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.files.getFiles.useSuspenseQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetFilesData>(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options?: Omit<UseSuspenseQueryOptions<GetFilesData, GetFilesError, TData, ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetFilesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.files.getFiles.useSuspenseInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetFilesParameters, TData = GetFilesData>(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<GetFilesData, GetFilesError, OperationInfiniteData<TData, GetFilesParameters>, ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetFilesData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetFilesParameters>, OperationError<GetFilesError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getFilesData = qraft.files.getFiles.useSuspenseQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getFilesCombinedData = qraft.files.getFiles.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFilesCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetFilesSchema, GetFilesParameters, GetFilesData, GetFilesError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetFilesData, GetFilesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetFilesData, GetFilesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get a files by ID */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, GetFilesError>): Promise<GetFilesData>;
        /** @summary Get a files by ID */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, GetFilesError>): Promise<void>;
        /** @summary Get a files by ID */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetFilesSchema, GetFilesData, GetFilesParameters, GetFilesError>): Promise<GetFilesData>;
        /** @summary Get a files by ID */
        fetchInfiniteQuery<TPageParam extends GetFilesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, DeepReadonly<TPageParam>, GetFilesError>): Promise<OperationInfiniteData<GetFilesData, GetFilesParameters>>;
        /** @summary Get a files by ID */
        prefetchInfiniteQuery<TPageParam extends GetFilesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFilesSchema, GetFilesData, GetFilesParameters, DeepReadonly<TPageParam>, GetFilesError>): Promise<void>;
        /** @summary Get a files by ID */
        ensureInfiniteQueryData<TPageParam extends GetFilesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetFilesSchema, GetFilesData, GetFilesParameters, DeepReadonly<TPageParam>, GetFilesError>): Promise<OperationInfiniteData<GetFilesData, GetFilesParameters>>;
        /** @summary Get a files by ID */
        getQueryData(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>)): GetFilesData | undefined;
        /** @summary Get a files by ID */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>)): OperationInfiniteData<GetFilesData, GetFilesParameters> | undefined;
        /** @summary Get a files by ID */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>,
            data: NoInfer<OperationInfiniteData<GetFilesData, GetFilesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>,
            data: GetFilesData | undefined
        ]>;
        /** @summary Get a files by ID */
        getQueryState(parameters: ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters> | (DeepReadonly<GetFilesParameters>)): QueryState<GetFilesData, GetFilesError> | undefined;
        /** @summary Get a files by ID */
        getInfiniteQueryState(parameters: DeepReadonly<GetFilesParameters> | ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>): QueryState<OperationInfiniteData<GetFilesData, GetFilesParameters>, GetFilesError> | undefined;
        /** @summary Get a files by ID */
        setQueryData(parameters: (DeepReadonly<GetFilesParameters>) | ServiceOperationQueryKey<GetFilesSchema, GetFilesParameters>, updater: Updater<NoInfer<GetFilesData> | undefined, NoInfer<DeepReadonly<GetFilesData>> | undefined>, options?: SetDataOptions): GetFilesData | undefined;
        /** @summary Get a files by ID */
        setInfiniteQueryData(parameters: (DeepReadonly<GetFilesParameters>) | ServiceOperationInfiniteQueryKey<GetFilesSchema, GetFilesParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetFilesData, GetFilesParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetFilesData, GetFilesParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetFilesData, GetFilesParameters> | undefined;
        /** @summary Get a files by ID */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, updater: Updater<NoInfer<GetFilesData> | undefined, NoInfer<GetFilesData> | undefined>, options?: SetDataOptions): Array<GetFilesData | undefined>;
        /** @summary Get a files by ID */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Get a files by ID */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: RefetchOptions): Promise<void>;
        /** @summary Get a files by ID */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: CancelOptions): Promise<void>;
        /** @summary Get a files by ID */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): void;
        /** @summary Get a files by ID */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>, options?: ResetOptions): Promise<void>;
        /** @summary Get a files by ID */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError> | QueryFiltersByQueryKey<GetFilesSchema, GetFilesData, TInfinite, GetFilesParameters, GetFilesError>): number;
        schema: GetFilesSchema;
        types: {
            parameters: GetFilesParameters;
            data: GetFilesData;
            error: GetFilesError;
        };
    };
    /** @summary Upload a files by ID */
    postFiles: {
        /** @summary Upload a files by ID */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<PostFilesBody, PostFilesParameters, TMeta, TSignal>, client?: (schema: PostFilesSchema, options: ServiceOperationMutationFnOptions<PostFilesBody, PostFilesParameters, TMeta, TSignal>) => Promise<RequestFnResponse<PostFilesData, PostFilesError>>): Promise<RequestFnResponse<PostFilesData, PostFilesError>>;
        /** @summary Upload a files by ID */
        getMutationKey(parameters: DeepReadonly<PostFilesParameters> | void): ServiceOperationMutationKey<PostFilesSchema, PostFilesParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.files.postFiles.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.files.postFiles.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostFilesBody, TContext = unknown>(parameters: DeepReadonly<PostFilesParameters>, options?: ServiceOperationUseMutationOptions<PostFilesSchema, PostFilesData, PostFilesParameters, TVariables, OperationError<PostFilesError>, TContext>): UseMutationResult<PostFilesData, OperationError<PostFilesError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.files.postFiles.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.files.postFiles.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostFilesBody, PostFilesParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostFilesSchema, PostFilesData, PostFilesParameters, TVariables, OperationError<PostFilesError>, TContext>): UseMutationResult<PostFilesData, OperationError<PostFilesError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postFilesTotal = qraft.files.postFiles.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postFilesTotal = qraft.files.postFiles.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postFilesPendingMutationVariables = qraft.files.postFiles.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postFilesMutationData = qraft.files.postFiles.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostFilesData, OperationError<PostFilesError>, MutationVariables<PostFilesBody, PostFilesParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext>;
            select?: (mutation: Mutation<PostFilesData, OperationError<PostFilesError>, MutationVariables<PostFilesBody, PostFilesParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Upload a files by ID */
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Upload a files by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.files.postFiles.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.files.postFiles.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext>): Mutation<PostFilesData, PostFilesError, MutationVariables<PostFilesBody, PostFilesParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext> | MutationFiltersByMutationKey<PostFilesSchema, PostFilesBody, PostFilesData, PostFilesParameters, OperationError<PostFilesError>, TContext>): Array<Mutation<PostFilesData, PostFilesError, MutationVariables<PostFilesBody, PostFilesParameters>, TContext>>;
        };
        schema: PostFilesSchema;
        types: {
            parameters: PostFilesParameters;
            data: PostFilesData;
            error: PostFilesError;
            body: PostFilesBody;
        };
    };
    /** @summary Delete all files */
    deleteFiles: {
        /** @summary Delete all files */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<DeleteFilesBody, DeleteFilesParameters, TMeta, TSignal>, client?: (schema: DeleteFilesSchema, options: ServiceOperationMutationFnOptions<DeleteFilesBody, DeleteFilesParameters, TMeta, TSignal>) => Promise<RequestFnResponse<DeleteFilesData, DeleteFilesError>>): Promise<RequestFnResponse<DeleteFilesData, DeleteFilesError>>;
        /** @summary Delete all files */
        getMutationKey(parameters: DeepReadonly<DeleteFilesParameters> | void): ServiceOperationMutationKey<DeleteFilesSchema, DeleteFilesParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.files.deleteFiles.useMutation({
         *     query: {
         *         all: all
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.files.deleteFiles.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         all: all
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteFilesBody, TContext = unknown>(parameters: DeepReadonly<DeleteFilesParameters>, options?: ServiceOperationUseMutationOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, TVariables, OperationError<DeleteFilesError>, TContext>): UseMutationResult<DeleteFilesData, OperationError<DeleteFilesError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.files.deleteFiles.useMutation({
         *     query: {
         *         all: all
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.files.deleteFiles.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         all: all
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteFilesSchema, DeleteFilesData, DeleteFilesParameters, TVariables, OperationError<DeleteFilesError>, TContext>): UseMutationResult<DeleteFilesData, OperationError<DeleteFilesError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteFilesTotal = qraft.files.deleteFiles.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteFilesTotal = qraft.files.deleteFiles.useIsMutating({
         *     parameters: {
         *         query: {
         *             all: all
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteFilesPendingMutationVariables = qraft.files.deleteFiles.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteFilesMutationData = qraft.files.deleteFiles.useMutationState({
         *     filters: {
         *         parameters: {
         *             query: {
         *                 all: all
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteFilesData, OperationError<DeleteFilesError>, MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext>;
            select?: (mutation: Mutation<DeleteFilesData, OperationError<DeleteFilesError>, MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Delete all files */
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Delete all files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.files.deleteFiles.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         query: {
         *             all: all
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.files.deleteFiles.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext>): Mutation<DeleteFilesData, DeleteFilesError, MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext> | MutationFiltersByMutationKey<DeleteFilesSchema, DeleteFilesBody, DeleteFilesData, DeleteFilesParameters, OperationError<DeleteFilesError>, TContext>): Array<Mutation<DeleteFilesData, DeleteFilesError, MutationVariables<DeleteFilesBody, DeleteFilesParameters>, TContext>>;
        };
        schema: DeleteFilesSchema;
        types: {
            parameters: DeleteFilesParameters;
            data: DeleteFilesData;
            error: DeleteFilesError;
            body: DeleteFilesBody;
        };
    };
    /** @summary Trash files */
    trashFiles: {
        /** @summary Trash files */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<TrashFilesBody, TrashFilesParameters, TMeta, TSignal>, client?: (schema: TrashFilesSchema, options: ServiceOperationMutationFnOptions<TrashFilesBody, TrashFilesParameters, TMeta, TSignal>) => Promise<RequestFnResponse<TrashFilesData, TrashFilesError>>): Promise<RequestFnResponse<TrashFilesData, TrashFilesError>>;
        /** @summary Trash files */
        getMutationKey(parameters: DeepReadonly<TrashFilesParameters> | void): ServiceOperationMutationKey<TrashFilesSchema, TrashFilesParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Trash files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.files.trashFiles.useMutation({
         *     query: {
         *         pendingOnly: pendingOnly
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.files.trashFiles.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         pendingOnly: pendingOnly
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends TrashFilesBody, TContext = unknown>(parameters: DeepReadonly<TrashFilesParameters>, options?: ServiceOperationUseMutationOptions<TrashFilesSchema, TrashFilesData, TrashFilesParameters, TVariables, OperationError<TrashFilesError>, TContext>): UseMutationResult<TrashFilesData, OperationError<TrashFilesError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Trash files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.files.trashFiles.useMutation({
         *     query: {
         *         pendingOnly: pendingOnly
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.files.trashFiles.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         pendingOnly: pendingOnly
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<TrashFilesBody, TrashFilesParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<TrashFilesSchema, TrashFilesData, TrashFilesParameters, TVariables, OperationError<TrashFilesError>, TContext>): UseMutationResult<TrashFilesData, OperationError<TrashFilesError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Trash files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const trashFilesTotal = qraft.files.trashFiles.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const trashFilesTotal = qraft.files.trashFiles.useIsMutating({
         *     parameters: {
         *         query: {
         *             pendingOnly: pendingOnly
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext> | MutationFiltersByMutationKey<TrashFilesSchema, TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Trash files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const trashFilesPendingMutationVariables = qraft.files.trashFiles.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const trashFilesMutationData = qraft.files.trashFiles.useMutationState({
         *     filters: {
         *         parameters: {
         *             query: {
         *                 pendingOnly: pendingOnly
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<TrashFilesData, OperationError<TrashFilesError>, MutationVariables<TrashFilesBody, TrashFilesParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext> | MutationFiltersByMutationKey<TrashFilesSchema, TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext>;
            select?: (mutation: Mutation<TrashFilesData, OperationError<TrashFilesError>, MutationVariables<TrashFilesBody, TrashFilesParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Trash files */
        isMutating<TContext>(filters?: MutationFiltersByParameters<TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext> | MutationFiltersByMutationKey<TrashFilesSchema, TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Trash files
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.files.trashFiles.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         query: {
         *             pendingOnly: pendingOnly
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.files.trashFiles.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext> | MutationFiltersByMutationKey<TrashFilesSchema, TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext>): Mutation<TrashFilesData, TrashFilesError, MutationVariables<TrashFilesBody, TrashFilesParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext> | MutationFiltersByMutationKey<TrashFilesSchema, TrashFilesBody, TrashFilesData, TrashFilesParameters, OperationError<TrashFilesError>, TContext>): Array<Mutation<TrashFilesData, TrashFilesError, MutationVariables<TrashFilesBody, TrashFilesParameters>, TContext>>;
        };
        schema: TrashFilesSchema;
        types: {
            parameters: TrashFilesParameters;
            data: TrashFilesData;
            error: TrashFilesError;
            body: TrashFilesBody;
        };
    };
    /**
     * @deprecated
     * @summary Get a file list
     */
    getFileList: {
        /**
         * @deprecated
         * @summary Get a file list
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetFileListSchema, GetFileListParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetFileListParameters, TMeta, TSignal> | void), client?: (schema: GetFileListSchema, options: {
            parameters: GetFileListParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetFileListData, GetFileListError>>): Promise<RequestFnResponse<GetFileListData, GetFileListError>>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueryKey(parameters: DeepReadonly<GetFileListParameters> | void): ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.files.getFileList.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.files.getFileList.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<DefinedInitialDataOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetFileListError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.files.getFileList.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.files.getFileList.useQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options?: Omit<UndefinedInitialDataOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetFileListError>>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetFileListParameters> | void): ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.files.getFileList.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFileListParameters, TQueryFnData = GetFileListData, TData = OperationInfiniteData<TQueryFnData, GetFileListParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetFileListError, TData, ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetFileListError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.files.getFileList.useInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetFileListParameters, TQueryFnData = GetFileListData, TData = OperationInfiniteData<TQueryFnData, GetFileListParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetFileListError, TData, ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetFileListError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getFileListTotal = qraft.files.getFileList.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getFileListByParametersTotal = qraft.files.getFileList.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         header: {
         *             "x-monite-version": "2023-06-04"
         *         },
         *         query: {
         *             id__in: idIn
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getFileListResults = qraft.files.getFileList.useQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getFileListCombinedResults = qraft.files.getFileList.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetFileListSchema, GetFileListParameters, GetFileListData, GetFileListError>>, TCombinedResult = Array<UseQueryResult<GetFileListData, GetFileListError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetFileListData, GetFileListError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.files.getFileList.useSuspenseQuery()
         * ```
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.files.getFileList.useSuspenseQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     },
         *     query: {
         *         id__in: idIn
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetFileListData>(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options?: Omit<UseSuspenseQueryOptions<GetFileListData, GetFileListError, TData, ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetFileListError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.files.getFileList.useSuspenseInfiniteQuery({
         *     header: {
         *         "x-monite-version": "2023-06-04"
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             id__in: initialIdIn
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetFileListParameters, TData = GetFileListData>(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetFileListData, GetFileListError, OperationInfiniteData<TData, GetFileListParameters>, ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetFileListData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetFileListParameters>, OperationError<GetFileListError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @deprecated
         * @summary Get a file list
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getFileListData = qraft.files.getFileList.useSuspenseQueries({
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getFileListCombinedData = qraft.files.getFileList.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn1
         *             }
         *         },
         *         {
         *             header: {
         *                 "x-monite-version": "2023-06-04"
         *             },
         *             query: {
         *                 id__in: idIn2
         *             }
         *         }
         *     ]
         * });
         * getFileListCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetFileListSchema, GetFileListParameters, GetFileListData, GetFileListError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetFileListData, GetFileListError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetFileListData, GetFileListError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @deprecated
         * @summary Get a file list
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, GetFileListError> | void): Promise<GetFileListData>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, GetFileListError> | void): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetFileListSchema, GetFileListData, GetFileListParameters, GetFileListError> | void): Promise<GetFileListData>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        fetchInfiniteQuery<TPageParam extends GetFileListParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, DeepReadonly<TPageParam>, GetFileListError> | void): Promise<OperationInfiniteData<GetFileListData, GetFileListParameters>>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        prefetchInfiniteQuery<TPageParam extends GetFileListParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetFileListSchema, GetFileListData, GetFileListParameters, DeepReadonly<TPageParam>, GetFileListError> | void): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        ensureInfiniteQueryData<TPageParam extends GetFileListParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetFileListSchema, GetFileListData, GetFileListParameters, DeepReadonly<TPageParam>, GetFileListError> | void): Promise<OperationInfiniteData<GetFileListData, GetFileListParameters>>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void)): GetFileListData | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void)): OperationInfiniteData<GetFileListData, GetFileListParameters> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>,
            data: NoInfer<OperationInfiniteData<GetFileListData, GetFileListParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>,
            data: GetFileListData | undefined
        ]>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters> | (DeepReadonly<GetFileListParameters> | void)): QueryState<GetFileListData, GetFileListError> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetFileListParameters> | ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters> | void): QueryState<OperationInfiniteData<GetFileListData, GetFileListParameters>, GetFileListError> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        setQueryData(parameters: (DeepReadonly<GetFileListParameters> | undefined) | ServiceOperationQueryKey<GetFileListSchema, GetFileListParameters>, updater: Updater<NoInfer<GetFileListData> | undefined, NoInfer<DeepReadonly<GetFileListData>> | undefined>, options?: SetDataOptions): GetFileListData | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetFileListParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetFileListSchema, GetFileListParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetFileListData, GetFileListParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetFileListData, GetFileListParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetFileListData, GetFileListParameters> | undefined;
        /**
         * @deprecated
         * @summary Get a file list
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, updater: Updater<NoInfer<GetFileListData> | undefined, NoInfer<GetFileListData> | undefined>, options?: SetDataOptions): Array<GetFileListData | undefined>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: RefetchOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: CancelOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): void;
        /**
         * @deprecated
         * @summary Get a file list
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>, options?: ResetOptions): Promise<void>;
        /**
         * @deprecated
         * @summary Get a file list
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError> | QueryFiltersByQueryKey<GetFileListSchema, GetFileListData, TInfinite, GetFileListParameters, GetFileListError>): number;
        schema: GetFileListSchema;
        types: {
            parameters: GetFileListParameters;
            data: GetFileListData;
            error: GetFileListError;
        };
    };
}
/** @summary Get a files by ID */
export const getFiles = {
    schema: {
        method: "get",
        url: "/files",
        security: ["HTTPBearer"]
    }
} as {
    schema: GetFilesSchema;
    [QraftServiceOperationsToken]: FilesService["getFiles"];
};
/** @summary Upload a files by ID */
export const postFiles = {
    schema: {
        method: "post",
        url: "/files",
        mediaType: ["multipart/form-data"]
    }
} as {
    schema: PostFilesSchema;
    [QraftServiceOperationsToken]: FilesService["postFiles"];
};
/** @summary Delete all files */
export const deleteFiles = {
    schema: {
        method: "delete",
        url: "/files"
    }
} as {
    schema: DeleteFilesSchema;
    [QraftServiceOperationsToken]: FilesService["deleteFiles"];
};
/** @summary Trash files */
export const trashFiles = {
    schema: {
        method: "delete",
        url: "/files/trash"
    }
} as {
    schema: TrashFilesSchema;
    [QraftServiceOperationsToken]: FilesService["trashFiles"];
};
/**
 * @deprecated
 * @summary Get a file list
 */
export const getFileList = {
    schema: {
        method: "get",
        url: "/files/list",
        security: ["HTTPBearer"]
    }
} as {
    schema: GetFileListSchema;
    [QraftServiceOperationsToken]: FilesService["getFileList"];
};
export const filesService = {
    getFiles,
    postFiles,
    deleteFiles,
    trashFiles,
    getFileList
} as const;
type GetFilesSchema = {
    method: "get";
    url: "/files";
    security: [
        "HTTPBearer"
    ];
};
type GetFilesParameters = ParametersWrapper<GetFilesSchema, paths["/files"]["get"], GetFilesData, GetFilesError>;
type GetFilesData = paths["/files"]["get"]["responses"]["200"]["content"]["application/json"];
type GetFilesError = paths["/files"]["get"]["responses"]["405"]["content"]["application/json"] | paths["/files"]["get"]["responses"]["422"]["content"]["application/json"] | paths["/files"]["get"]["responses"]["default"]["content"]["application/json"];
type PostFilesSchema = {
    method: "post";
    url: "/files";
    mediaType: [
        "multipart/form-data"
    ];
};
type PostFilesParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type PostFilesData = paths["/files"]["post"]["responses"]["200"]["content"]["application/json"];
type PostFilesError = paths["/files"]["post"]["responses"]["default"]["content"]["application/json"];
type PostFilesBody = NonNullable<paths["/files"]["post"]["requestBody"]>["content"]["multipart/form-data"] | FormData;
type DeleteFilesSchema = {
    method: "delete";
    url: "/files";
};
type DeleteFilesParameters = paths["/files"]["delete"]["parameters"];
type DeleteFilesData = paths["/files"]["delete"]["responses"]["200"]["content"]["application/json"] | null;
type DeleteFilesError = paths["/files"]["delete"]["responses"]["default"]["content"]["application/json"];
type DeleteFilesBody = undefined;
type TrashFilesSchema = {
    method: "delete";
    url: "/files/trash";
};
type TrashFilesParameters = paths["/files/trash"]["delete"]["parameters"];
type TrashFilesData = paths["/files/trash"]["delete"]["responses"]["200"]["content"]["application/json"] | paths["/files/trash"]["delete"]["responses"]["200"]["content"]["application/octet-stream"] | null;
type TrashFilesError = paths["/files/trash"]["delete"]["responses"]["default"]["content"]["application/json"];
type TrashFilesBody = undefined;
type GetFileListSchema = {
    method: "get";
    url: "/files/list";
    security: [
        "HTTPBearer"
    ];
};
type GetFileListParameters = ParametersWrapper<GetFileListSchema, paths["/files/list"]["get"], GetFileListData, GetFileListError>;
type GetFileListData = paths["/files/list"]["get"]["responses"]["200"]["content"]["application/json"];
type GetFileListError = paths["/files/list"]["get"]["responses"]["default"]["content"]["application/json"];
